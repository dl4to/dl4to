---

title: Topo solvers


keywords: fastai
sidebar: home_sidebar



nb_path: "notebooks/tutorials/3_tutorial_topo_solvers.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/tutorials/3_tutorial_topo_solvers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this tutorial you learn how to</p>
<ul>
<li>use optimization criteria as objective functions or as evaluation metrics</li>
<li>use our topo solvers, particularly our SIMP topo solver</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we actually start performing topology optimization!</p>
<p>The <a href="/dl4totopo_solver.html#TopoSolver"><code>TopoSolver</code></a> class inherits all types of methods for solving TO problems. This contains the famous SIMP method, deep learning-based methods, as well as arbitrary combinations of these two.</p>
<p>In this chapter we start with an introduction of how our optimization pipeline works. For now, we will focus mainly on the SIMP method and we will discuss learned methods in the next tutorial.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Criteria">Criteria<a class="anchor-link" href="#Criteria"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For any topo solver we need to choose an optimization criterion, i.e., an objective function and constraints for which we want to optimize. Our library contains many criteria that can be used for evaluation or as objective functions. Generally speaking, we have two different types of criteria: supervised and unsupervised.</p>
<ul>
<li><strong>Supervised criteria</strong> compare a given solution to a ground truth solution. These include for instance common loss functions like the "binary cross entropy" (BCE) as well as many commonly used evaluation criteria for semantic segmentation, like the "Intersection over Union" (IoU) and "Dice". </li>
<li><strong>Unsupervised criteria</strong> don't require a ground truth and evaluate inputs based on their intrinsic properties. They include criteria for volume, maximal stress and compliance.</li>
</ul>
<p>We will use some of the mentioned criteria in this and in the next tutorial on trainable topo solvers.</p>
<p>For SIMP, we use compliance minimization with a volume constraint:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">Compliance</span><span class="p">,</span> <span class="n">VolumeConstraint</span>

<span class="n">criterion</span> <span class="o">=</span> <span class="n">Compliance</span><span class="p">()</span> <span class="o">+</span> <span class="n">VolumeConstraint</span><span class="p">(</span><span class="n">max_volume_fraction</span><span class="o">=</span><span class="mf">.12</span><span class="p">,</span> <span class="n">threshold_fct</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/dl4tounsupervised_criteria.html#Compliance"><code>Compliance</code></a> is a very common objective in topology optimization. It is defined as the product of external forces and displacements. The <a href="/dl4tounsupervised_criteria.html#VolumeConstraint"><code>VolumeConstraint</code></a> criterion compares the volume fraction -- i.e., the average voxel density -- wit a pre-defined maximum volume fraction (which in this case is 0.12). If the difference is negative (i.e., the current volume is below the maximum volume fraction) then this criterion returns 0, otherwise it returns a positive output. The thresholding can be done either via ReLU or Softplus. Both <a href="/dl4tounsupervised_criteria.html#Compliance"><code>Compliance</code></a> and <a href="/dl4tounsupervised_criteria.html#VolumeConstraint"><code>VolumeConstraint</code></a> are unsupervised criteria.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For our TO problem we choose the first sample of the disc complex SELTO dataset and we pass an FDM solver to it:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.datasets</span> <span class="kn">import</span> <span class="n">SELTODataset</span>
<span class="kn">from</span> <span class="nn">dl4to.pde</span> <span class="kn">import</span> <span class="n">FDM</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">SELTODataset</span><span class="p">(</span><span class="s2">&quot;/localdata/dl4to_dataset&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;disc_complex&#39;</span><span class="p">)</span>
<span class="n">problem</span><span class="p">,</span> <span class="n">gt_solution</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">problem</span><span class="o">.</span><span class="n">pde_solver</span> <span class="o">=</span> <span class="n">FDM</span><span class="p">(</span><span class="n">padding_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Found 7337 files.
importing dataset...
done!
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-SIMP-method">The SIMP method<a class="anchor-link" href="#The-SIMP-method"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The Solid Isotropic Material with Penalization (SIMP) method is widely regarded as the most significant classical approach used in TO. SIMP employs an iterative optimization scheme to improve structural performance by adjusting voxel densities. See Algorithm 1 for a full breakdown of the steps that are part of the SIMP algorithm:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/3_simp.png" alt="title"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We initialize SIMP as follows, with a learning rate of 0.3:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.topo_solvers</span> <span class="kn">import</span> <span class="n">SIMP</span>

<span class="n">simp</span> <span class="o">=</span> <span class="n">SIMP</span><span class="p">(</span>
    <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
    <span class="n">binarizer_steepening_factor</span><span class="o">=</span><span class="mf">1.02</span><span class="p">,</span>
    <span class="n">n_iterations</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
    <span class="n">lr</span><span class="o">=</span><span class="mf">3e-1</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-apply-topo-solvers-to-a-TO-problem">How to apply topo solvers to a TO problem<a class="anchor-link" href="#How-to-apply-topo-solvers-to-a-TO-problem"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In order to apply a topo_solver to a problem, we can simply call it via <code>solution = topo_solver(problem)</code>, which returns a solution object. This also works with a list of problems as input, in which case topo solver likewise returns a list of solutions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solution</span> <span class="o">=</span> <span class="n">simp</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's take a look at the solution of the SIMP algorithm:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.06</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">)</span>
<span class="n">solution</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
              <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">solve_pde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/3_density_disc.png" alt="density">
<img src="https://dl4to.github.io/dl4to/images/3_displacements_disc.png" alt="displacements">
<img src="https://dl4to.github.io/dl4to/images/3_stresses_disc.png" alt="stresses"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that the output of the SIMP algorithm returns indeed a plausible solution to the TO problem. Note that if you wish to rerun SIMP with the same <code>simp</code> instance, you should run <code>simp.reset()</code> prior to that. This is done in order to reset SIMP optimization parameters.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can observe that the volume fraction of the SIMP solution is almost exactly 0.12:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">VolumeFraction</span>

<span class="n">volume_fraction</span> <span class="o">=</span> <span class="n">VolumeFraction</span><span class="p">()</span>
<span class="n">volume_fraction</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.1203], grad_fn=&lt;DivBackward0&gt;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With DL4TO we provide an unsupervised criterion called <a href="/dl4tounsupervised_criteria.html#Binariness"><code>Binariness</code></a> which determines how binary the solution is. A value of $1$ means that it is fully binary, while a lower value signifies that there are more values around $0.5$. We see that our solution is almost fully binary:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">Binariness</span>

<span class="n">binariness</span> <span class="o">=</span> <span class="n">Binariness</span><span class="p">()</span>
<span class="n">binariness</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.9042])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As we can observe from the above 3D plot, the von Mises stresses are well below the yield stress. The <a href="/dl4tounsupervised_criteria.html#MaxStress"><code>MaxStress</code></a> criterion confirms this with a normalized maximal stress of less than a quarter of the maximum value of 1:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">MaxStress</span>

<span class="n">max_stress</span> <span class="o">=</span> <span class="n">MaxStress</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">max_stress</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.2151], grad_fn=&lt;DivBackward0&gt;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

